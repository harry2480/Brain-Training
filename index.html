<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>脳トレ・ジム</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel (JSX変換用) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
            touch-action: manipulation; /* ダブルタップズーム防止 */
        }
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.4s ease-out forwards;
        }
        @keyframes popup {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
        .animate-popup {
            animation: popup 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="bg-slate-200 min-h-screen flex justify-center items-center p-2 text-gray-900">

    <div id="root" class="w-full max-w-lg"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons (Inline SVG) ---
        // 外部ライブラリ依存を避けるため、必要なアイコンをSVGコンポーネントとして定義

        const IconBase = ({ children, className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Brain = ({ className }) => <IconBase className={className}><path d="M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z"/><path d="M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z"/><path d="M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4"/></IconBase>;
        const Calculator = ({ className }) => <IconBase className={className}><rect width="16" height="20" x="4" y="2" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="14" y2="18"/><path d="M16 10h.01"/><path d="M12 10h.01"/><path d="M8 10h.01"/><path d="M12 14h.01"/><path d="M8 14h.01"/><path d="M12 18h.01"/><path d="M8 18h.01"/></IconBase>;
        const Palette = ({ className }) => <IconBase className={className}><circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/><circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/><circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/><circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></IconBase>;
        const Grid3X3 = ({ className }) => <IconBase className={className}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></IconBase>;
        const Grid2X2 = ({ className }) => <IconBase className={className}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 12h18"/><path d="M12 3v18"/></IconBase>;
        const Clock = ({ className }) => <IconBase className={className}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></IconBase>;
        const Trophy = ({ className }) => <IconBase className={className}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></IconBase>;
        const Home = ({ className }) => <IconBase className={className}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></IconBase>;
        const RotateCcw = ({ className }) => <IconBase className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
        const X = ({ className }) => <IconBase className={className}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>;
        const Check = ({ className }) => <IconBase className={className}><path d="M20 6 9 17l-5-5"/></IconBase>;
        const Hash = ({ className }) => <IconBase className={className}><line x1="4" x2="20" y1="9" y2="9"/><line x1="4" x2="20" y1="15" y2="15"/><line x1="10" x2="8" y1="3" y2="21"/><line x1="16" x2="14" y1="3" y2="21"/></IconBase>;
        const Play = ({ className }) => <IconBase className={className}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const Circle = ({ className }) => <IconBase className={className}><circle cx="12" cy="12" r="10"/></IconBase>;

        // Custom Hand Icons
        const RockHand = ({ className }) => (
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M7.5 11c-1.5 0-2.5 1-2.5 2.5v5c0 1.5 1 2.5 2.5 2.5h9c1.5 0 2.5-1 2.5-2.5v-5c0-1.5-1-2.5-2.5-2.5h-9z" />
                <path d="M6 13c-1.5 0-2-1-2-2.5V8a2.5 2.5 0 0 1 5 0v3" />
                <path d="M9 11V6a2.5 2.5 0 0 1 5 0v5" />
                <path d="M13 11V7a2.5 2.5 0 0 1 5 0v4" />
                <path d="M6 15h12" opacity="0.5"/>
            </svg>
        );
        const ScissorsHand = ({ className }) => (
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M18 20V8a2 2 0 0 0-2-2h-1a2 2 0 0 0-2 2v4" />
                <path d="M12 12V3a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v10" />
                <path d="M15.5 21H8a3 3 0 0 1-3-3v-3a4 4 0 0 1 4-4h2" />
                <path d="M16 21a2 2 0 0 0 2-2" />
                <path d="M6 15l2 1" />
            </svg>
        );
        const PaperHand = ({ className }) => (
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" />
                <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" />
                <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" />
                <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" />
            </svg>
        );

        // --- Shared Components ---

        const Button = ({ children, onClick, className = "", variant = "primary", disabled = false }) => {
            const baseStyle = "w-full font-bold py-4 px-6 rounded-2xl shadow-md transition-all transform active:scale-95 flex items-center justify-center gap-3 text-xl"; 
            const variants = {
                primary: "bg-blue-600 text-white hover:bg-blue-700 disabled:bg-blue-300",
                secondary: "bg-white text-gray-900 border-4 border-gray-300 hover:bg-gray-100 disabled:bg-gray-100",
                success: "bg-green-600 text-white hover:bg-green-700 disabled:bg-green-300",
                danger: "bg-red-600 text-white hover:bg-red-700 disabled:bg-red-300",
                warning: "bg-yellow-400 text-yellow-900 hover:bg-yellow-500 disabled:bg-yellow-200",
                rock: "bg-gray-600 text-white hover:bg-gray-700 border-b-4 border-gray-800 active:border-b-0 active:translate-y-1",
                paper: "bg-white text-gray-900 border-4 border-gray-400 hover:bg-gray-50 border-b-8 active:border-b-4 active:translate-y-1",
                scissors: "bg-orange-500 text-white hover:bg-orange-600 border-b-4 border-orange-700 active:border-b-0 active:translate-y-1",
            };
            return (
                <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${variants[variant] || variants.primary} ${className}`}>
                    {children}
                </button>
            );
        };

        const FeedbackOverlay = ({ type }) => {
            if (!type) return null;
            return (
                <div className="absolute inset-0 flex items-center justify-center z-50 pointer-events-none">
                <div className={`animate-popup transform ${type === 'correct' ? 'text-green-500' : 'text-red-500'}`}>
                    {type === 'correct' ? <Circle className="w-48 h-48 stroke-[6] opacity-80" /> : <X className="w-48 h-48 stroke-[6] opacity-80" />}
                </div>
                </div>
            );
        };

        const GameHeader = ({ title, score, timeLeft, onExit, color }) => (
            <div className="flex flex-col gap-4 mb-4 shrink-0">
                <div className="flex justify-between items-center bg-white p-2 rounded-xl shadow-sm">
                    <button onClick={onExit} className="flex items-center gap-2 px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300 transition-colors">
                        <Home className="w-6 h-6 text-gray-700" />
                        <span className="font-bold text-gray-700 text-lg">戻る</span>
                    </button>
                    <h2 className={`text-2xl font-black ${color}`}>{title}</h2>
                </div>
                <div className="flex justify-between items-end bg-white p-4 rounded-2xl shadow-md border-2 border-gray-100">
                    <div className="flex flex-col">
                        <span className="text-sm text-gray-500 font-bold tracking-wider">のこり時間</span>
                        <div className={`text-4xl font-mono font-black flex items-center gap-2 ${timeLeft <= 5 ? 'text-red-600 animate-pulse' : 'text-gray-900'}`}>
                            <Clock className="w-8 h-8" /> {timeLeft}
                        </div>
                    </div>
                    <div className="flex flex-col items-end">
                        <span className="text-sm text-gray-500 font-bold tracking-wider">スコア</span>
                        <span className="text-4xl font-mono font-black text-gray-900">{score}</span>
                    </div>
                </div>
            </div>
        );

        // --- Game Hooks ---

        const useMathGame = (onGameOver) => {
            const [problem, setProblem] = useState({ q: "", a: 0 });
            const [options, setOptions] = useState([]);
            const [score, setScore] = useState(0);
            const [timeLeft, setTimeLeft] = useState(30);
            const [isActive, setIsActive] = useState(false);

            useEffect(() => {
                if (isActive && timeLeft > 0) {
                    const timer = setTimeout(() => setTimeLeft(t => t - 1), 1000);
                    return () => clearTimeout(timer);
                } else if (isActive && timeLeft === 0) {
                    setIsActive(false);
                    onGameOver(score);
                }
            }, [isActive, timeLeft, onGameOver, score]);

            const generateProblem = () => {
                const operators = ['+', '-', '*'];
                const operator = operators[Math.floor(Math.random() * operators.length)];
                let a, b, answer;
                if (operator === '*') {
                    a = Math.floor(Math.random() * 9) + 2;
                    b = Math.floor(Math.random() * 9) + 2;
                    answer = a * b;
                } else {
                    a = Math.floor(Math.random() * 50) + 1;
                    b = Math.floor(Math.random() * 50) + 1;
                    if (operator === '-' && a < b) [a, b] = [b, a];
                    answer = operator === '+' ? a + b : a - b;
                }
                const opts = new Set([answer]);
                while (opts.size < 4) {
                    const offset = Math.floor(Math.random() * 10) - 5;
                    const val = answer + offset;
                    if (val >= 0 && val !== answer) opts.add(val);
                }
                setProblem({ q: `${a} ${operator === '*' ? '×' : operator} ${b}`, a: answer });
                setOptions(Array.from(opts).sort(() => Math.random() - 0.5));
            };

            const startGame = () => {
                setScore(0);
                setTimeLeft(30);
                setIsActive(true);
                generateProblem();
            };

            const handleAnswer = (val) => {
                const isCorrect = val === problem.a;
                if (isCorrect) {
                    setScore(s => s + 10);
                    generateProblem();
                } else {
                    setScore(s => Math.max(0, s - 5));
                }
                return isCorrect;
            };

            return { problem, options, score, timeLeft, isActive, startGame, handleAnswer };
        };

        const useColorGame = (onGameOver) => {
            const [current, setCurrent] = useState({ text: "", color: "", isMatch: false });
            const [score, setScore] = useState(0);
            const [timeLeft, setTimeLeft] = useState(30);
            const [isActive, setIsActive] = useState(false);
            const colors = [
                { name: "あか", class: "text-red-600" },
                { name: "あお", class: "text-blue-600" },
                { name: "みどり", class: "text-green-600" },
                { name: "きいろ", class: "text-yellow-500" },
                { name: "くろ", class: "text-gray-900" },
            ];

            useEffect(() => {
                if (isActive && timeLeft > 0) {
                    const timer = setTimeout(() => setTimeLeft(t => t - 1), 1000);
                    return () => clearTimeout(timer);
                } else if (isActive && timeLeft === 0) {
                    setIsActive(false);
                    onGameOver(score);
                }
            }, [isActive, timeLeft, onGameOver, score]);

            const generateRound = () => {
                const shouldMatch = Math.random() > 0.5;
                const textIdx = Math.floor(Math.random() * colors.length);
                let colorIdx = textIdx;
                if (!shouldMatch) {
                    while (colorIdx === textIdx) {
                        colorIdx = Math.floor(Math.random() * colors.length);
                    }
                }
                setCurrent({
                    text: colors[textIdx].name,
                    color: colors[colorIdx].class,
                    isMatch: shouldMatch
                });
            };

            const startGame = () => {
                setScore(0);
                setTimeLeft(30);
                setIsActive(true);
                generateRound();
            };

            const handleAnswer = (userSaysMatch) => {
                const isCorrect = userSaysMatch === current.isMatch;
                if (isCorrect) {
                    setScore(s => s + 10);
                    generateRound();
                } else {
                    setScore(s => Math.max(0, s - 10));
                    generateRound();
                }
                return isCorrect;
            };

            return { current, score, timeLeft, isActive, startGame, handleAnswer };
        };

        const useMemoryGame = (onGameOver) => {
            const [sequence, setSequence] = useState([]);
            const [userSequence, setUserSequence] = useState([]);
            const [gameState, setGameState] = useState('selecting');
            const [level, setLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [timeLeft, setTimeLeft] = useState(120);
            const [isActive, setIsActive] = useState(false);
            const [gridSize, setGridSize] = useState(4);

            useEffect(() => {
                if (isActive && timeLeft > 0) {
                    const timer = setTimeout(() => setTimeLeft(t => t - 1), 1000);
                    return () => clearTimeout(timer);
                } else if (isActive && timeLeft === 0) {
                    setIsActive(false);
                    onGameOver(score);
                }
            }, [isActive, timeLeft, onGameOver, score]);

            const generateSequence = (lvl, size) => {
                const totalCells = size * size;
                const maxCount = size === 3 ? 7 : 12;
                const count = Math.min(3 + Math.floor(lvl / 2), maxCount);
                const newSeq = [];
                while (newSeq.length < count) {
                    const idx = Math.floor(Math.random() * totalCells);
                    if (!newSeq.includes(idx)) newSeq.push(idx);
                }
                return newSeq;
            };

            const startGame = (size) => {
                setGridSize(size);
                setScore(0);
                setLevel(1);
                setTimeLeft(120);
                setIsActive(true);
                startLevel(1, size);
            };

            const startLevel = (lvl, size) => {
                const seq = generateSequence(lvl, size);
                setSequence(seq);
                setUserSequence([]);
                setGameState('showing');
                const showTime = Math.max(1200 - (lvl * 30), 500);
                setTimeout(() => {
                    setGameState('playing');
                }, showTime);
            };

            const handleClick = (idx) => {
                if (gameState !== 'playing') return null;
                if (sequence.includes(idx)) {
                    if (userSequence.includes(idx)) return null;
                    const newUserSeq = [...userSequence, idx];
                    setUserSequence(newUserSeq);
                    if (newUserSeq.length === sequence.length) {
                        const pointsPerCell = gridSize === 4 ? 20 : 10;
                        setScore(s => s + (sequence.length * pointsPerCell));
                        setGameState('success');
                        setTimeout(() => {
                            setLevel(l => l + 1);
                            startLevel(level + 1, gridSize);
                        }, 800);
                        return 'levelComplete';
                    }
                    return 'correct';
                } else {
                    setGameState('idle');
                    setIsActive(false);
                    onGameOver(score);
                    return 'wrong';
                }
            };

            return { sequence, userSequence, gameState, score, level, timeLeft, gridSize, startGame, handleClick };
        };

        const useRPSGame = (onGameOver) => {
            const [enemyHand, setEnemyHand] = useState(0);
            const [instruction, setInstruction] = useState(0);
            const [score, setScore] = useState(0);
            const [timeLeft, setTimeLeft] = useState(120);
            const [isActive, setIsActive] = useState(false);

            useEffect(() => {
                if (isActive && timeLeft > 0) {
                    const timer = setTimeout(() => setTimeLeft(t => t - 1), 1000);
                    return () => clearTimeout(timer);
                } else if (isActive && timeLeft === 0) {
                    setIsActive(false);
                    onGameOver(score);
                }
            }, [isActive, timeLeft, onGameOver, score]);

            const generateRound = () => {
                setEnemyHand(Math.floor(Math.random() * 3));
                setInstruction(Math.floor(Math.random() * 3));
            };

            const startGame = () => {
                setScore(0);
                setTimeLeft(120);
                setIsActive(true);
                generateRound();
            };

            const handleAnswer = (playerHand) => {
                let isCorrect = false;
                if (instruction === 0) { // Win
                    if ((enemyHand === 0 && playerHand === 2) || (enemyHand === 1 && playerHand === 0) || (enemyHand === 2 && playerHand === 1)) isCorrect = true;
                } else if (instruction === 1) { // Lose
                    if ((enemyHand === 0 && playerHand === 1) || (enemyHand === 1 && playerHand === 2) || (enemyHand === 2 && playerHand === 0)) isCorrect = true;
                } else { // Draw
                    if (enemyHand === playerHand) isCorrect = true;
                }
                if (isCorrect) {
                    setScore(s => s + 10);
                    generateRound();
                } else {
                    setScore(s => Math.max(0, s - 10));
                    generateRound();
                }
                return isCorrect;
            };

            return { enemyHand, instruction, score, timeLeft, isActive, startGame, handleAnswer };
        };

        const useNumberGame = (onGameOver) => {
            const [numbers, setNumbers] = useState([]);
            const [currentTarget, setCurrentTarget] = useState(1);
            const [score, setScore] = useState(0);
            const [timeLeft, setTimeLeft] = useState(60);
            const [isActive, setIsActive] = useState(false);
            const [maxNum] = useState(16);

            useEffect(() => {
                if (isActive && timeLeft > 0) {
                    const timer = setTimeout(() => setTimeLeft(t => t - 1), 1000);
                    return () => clearTimeout(timer);
                } else if (isActive && timeLeft === 0) {
                    setIsActive(false);
                    onGameOver(score);
                }
            }, [isActive, timeLeft, onGameOver, score]);

            const generateGrid = () => {
                const nums = Array.from({ length: maxNum }, (_, i) => i + 1);
                setNumbers(nums.sort(() => Math.random() - 0.5));
                setCurrentTarget(1);
            };

            const startGame = () => {
                setScore(0);
                setTimeLeft(60);
                setIsActive(true);
                generateGrid();
            };

            const handleClick = (num) => {
                if (!isActive) return false;
                if (num === currentTarget) {
                    setScore(s => s + 1);
                    if (currentTarget === maxNum) {
                        setScore(s => s + 20);
                        generateGrid();
                    } else {
                        setCurrentTarget(n => n + 1);
                    }
                    return true;
                }
                return false;
            };

            return { numbers, currentTarget, score, timeLeft, isActive, startGame, handleClick };
        };

        // --- Screens ---

        const MenuScreen = ({ onSelectGame, highScores }) => {
            const games = [
                { id: 'math', title: '計算アタック', icon: Calculator, desc: '計算力を鍛える', color: 'blue' },
                { id: 'color', title: '色彩ジャッジ', icon: Palette, desc: '判断力を鍛える', color: 'purple' },
                { id: 'memory', title: '瞬間メモリー', icon: Grid3X3, desc: '記憶力を鍛える', color: 'orange' },
                { id: 'rps', title: '後出しジャンケン', icon: PaperHand, desc: '瞬発力を鍛える', color: 'pink' },
                { id: 'number', title: '数字早押し', icon: Hash, desc: '視野を広げる', color: 'teal' },
            ];
            const colorClasses = {
                blue: "border-blue-500 text-blue-800",
                purple: "border-purple-500 text-purple-800",
                orange: "border-orange-500 text-orange-800",
                pink: "border-pink-500 text-pink-800",
                teal: "border-teal-500 text-teal-800",
            };
            const iconColors = {
                blue: "text-blue-600",
                purple: "text-purple-600",
                orange: "text-orange-600",
                pink: "text-pink-600",
                teal: "text-teal-600",
            };

            return (
                <div className="flex flex-col gap-5 max-w-md mx-auto w-full animate-fade-in h-full overflow-y-auto pb-6">
                    <div className="text-center space-y-2 mb-2 pt-4">
                        <h1 className="text-3xl font-extrabold text-gray-900 flex items-center justify-center gap-3">
                            <Brain className="w-10 h-10 text-indigo-700" />
                            脳トレ・ジム
                        </h1>
                        <p className="text-gray-600 text-lg font-bold">5つのゲームで脳を活性化！</p>
                    </div>
                    <div className="grid gap-4">
                        {games.map(game => (
                            <button key={game.id} onClick={() => onSelectGame(game.id)} className={`bg-white p-5 rounded-2xl shadow-lg border-l-[12px] hover:bg-gray-50 transition-all text-left group flex justify-between items-center ${colorClasses[game.color]}`}>
                                <div className="flex items-center gap-5">
                                    <div className={`p-3 rounded-full bg-gray-100`}>
                                        <game.icon className={`w-8 h-8 ${iconColors[game.color]}`} />
                                    </div>
                                    <div>
                                        <h3 className="text-2xl font-black text-gray-900">{game.title}</h3>
                                        <p className="text-gray-600 text-base font-bold mt-1">{game.desc}</p>
                                    </div>
                                </div>
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const MathGame = ({ onEnd, onExit }) => {
            const { problem, options, score, timeLeft, isActive, startGame, handleAnswer } = useMathGame(onEnd);
            const [feedback, setFeedback] = useState(null);
            useEffect(() => { startGame(); }, []);
            
            const onAnswer = (val) => {
                if (!isActive) return;
                const isCorrect = handleAnswer(val);
                setFeedback(null);
                setTimeout(() => setFeedback(isCorrect ? 'correct' : 'wrong'), 0);
                setTimeout(() => setFeedback(null), 500);
            };

            return (
                <div className="flex flex-col h-full relative">
                    <FeedbackOverlay type={feedback} />
                    <GameHeader title="計算アタック" score={score} timeLeft={timeLeft} onExit={onExit} color="text-blue-700" />
                    <div className="flex-1 flex flex-col justify-center items-center gap-10 py-4">
                        <div className="text-7xl font-black text-gray-900 tracking-wider drop-shadow-sm">{problem.q}</div>
                        <div className="grid grid-cols-2 gap-4 w-full">
                            {options.map((opt, i) => (
                                <button key={i} onClick={() => onAnswer(opt)} className="bg-white border-b-[6px] border-blue-200 active:border-b-0 active:translate-y-1 h-28 text-5xl font-black rounded-2xl shadow-md text-gray-800 hover:text-blue-700 hover:bg-blue-50 transition-all">{opt}</button>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const ColorGame = ({ onEnd, onExit }) => {
            const { current, score, timeLeft, isActive, startGame, handleAnswer } = useColorGame(onEnd);
            const [feedback, setFeedback] = useState(null);
            useEffect(() => { startGame(); }, []);

            const onAnswer = (bool) => {
                if (!isActive) return;
                const isCorrect = handleAnswer(bool);
                setFeedback(null);
                setTimeout(() => setFeedback(isCorrect ? 'correct' : 'wrong'), 0);
                setTimeout(() => setFeedback(null), 500);
            };

            return (
                <div className="flex flex-col h-full relative">
                    <FeedbackOverlay type={feedback} />
                    <GameHeader title="色彩ジャッジ" score={score} timeLeft={timeLeft} onExit={onExit} color="text-purple-700" />
                    <div className="flex-1 flex flex-col justify-center items-center gap-6 py-4">
                        <div className="bg-white rounded-[2rem] p-6 shadow-md border-2 border-gray-100 w-full flex flex-col items-center justify-center min-h-[200px]">
                            <div className={`text-8xl font-black ${current.color} drop-shadow-sm`}>{current.text}</div>
                        </div>
                        <p className="text-center text-gray-700 font-bold text-xl leading-relaxed">文字の意味と<br/><span className="text-2xl border-b-4 border-purple-300">色</span>は合ってる？</p>
                        <div className="flex gap-4 w-full mt-4">
                            <Button variant="danger" onClick={() => onAnswer(false)} disabled={!isActive} className="h-32 text-3xl flex-col"><X className="w-12 h-12" />ちがう</Button>
                            <Button variant="success" onClick={() => onAnswer(true)} disabled={!isActive} className="h-32 text-3xl flex-col"><Check className="w-12 h-12" />あってる</Button>
                        </div>
                    </div>
                </div>
            );
        };

        const MemoryGame = ({ onEnd, onExit }) => {
            const { sequence, userSequence, gameState, score, level, timeLeft, gridSize, startGame, handleClick } = useMemoryGame(onEnd);
            const [feedback, setFeedback] = useState(null);

            const onClickTile = (i) => {
                const result = handleClick(i);
                if (result === 'wrong') {
                    setFeedback('wrong');
                    setTimeout(() => setFeedback(null), 800);
                } else if (result === 'levelComplete') {
                    setFeedback('correct');
                    setTimeout(() => setFeedback(null), 800);
                }
            };

            if (gameState === 'selecting') {
                return (
                    <div className="flex flex-col h-full items-center justify-center">
                        <div className="w-full mb-8 flex justify-between items-center absolute top-6 left-0 px-6">
                            <button onClick={onExit} className="flex items-center gap-2 px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300"><Home className="w-6 h-6 text-gray-700" /><span className="font-bold text-gray-700 text-lg">戻る</span></button>
                        </div>
                        <div className="text-center mb-10">
                            <h2 className="text-4xl font-black text-orange-700 mb-4 flex justify-center gap-3 items-center"><Grid3X3 className="w-12 h-12" /> 瞬間メモリー</h2>
                            <p className="text-gray-600 text-xl font-bold">難易度を選んでください</p>
                        </div>
                        <div className="flex flex-col gap-6 w-full max-w-sm">
                            <button onClick={() => startGame(3)} className="bg-white border-l-[12px] border-green-500 p-6 rounded-2xl shadow-lg hover:bg-green-50 transition-all flex items-center justify-between group">
                                <div className="flex items-center gap-4">
                                    <div className="bg-green-100 p-4 rounded-full text-green-700"><Grid2X2 className="w-8 h-8" /></div>
                                    <div className="text-left"><h3 className="text-2xl font-black text-gray-800">かんたん</h3><p className="text-gray-600 font-bold">3 × 3 マス</p></div>
                                </div>
                                <Play className="w-8 h-8 text-gray-300 group-hover:text-green-500" />
                            </button>
                            <button onClick={() => startGame(4)} className="bg-white border-l-[12px] border-orange-500 p-6 rounded-2xl shadow-lg hover:bg-orange-50 transition-all flex items-center justify-between group">
                                <div className="flex items-center gap-4">
                                    <div className="bg-orange-100 p-4 rounded-full text-orange-700"><Grid3X3 className="w-8 h-8" /></div>
                                    <div className="text-left"><h3 className="text-2xl font-black text-gray-800">ふつう</h3><p className="text-gray-600 font-bold">4 × 4 マス</p></div>
                                </div>
                                <Play className="w-8 h-8 text-gray-300 group-hover:text-orange-500" />
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-full relative">
                    <FeedbackOverlay type={feedback} />
                    <div className="flex flex-col gap-4 mb-4 shrink-0">
                        <div className="flex justify-between items-center bg-white p-2 rounded-xl shadow-sm">
                            <button onClick={onExit} className="flex items-center gap-2 px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300"><Home className="w-6 h-6 text-gray-700" /><span className="font-bold text-gray-700 text-lg">戻る</span></button>
                            <h2 className="text-2xl font-black text-orange-700">瞬間メモリー</h2>
                        </div>
                        <div className="flex justify-between items-end bg-white p-4 rounded-2xl shadow-md border-2 border-gray-100">
                            <div className="flex flex-col">
                                <span className="text-sm text-gray-500 font-bold tracking-wider">のこり時間</span>
                                <div className={`text-4xl font-mono font-black flex items-center gap-2 ${timeLeft <= 5 ? 'text-red-600 animate-pulse' : 'text-gray-900'}`}>
                                    <Clock className="w-8 h-8" /> {timeLeft}
                                </div>
                            </div>
                            <div className="flex gap-6">
                                <div className="flex flex-col items-center"><span className="text-sm text-gray-500 font-bold">レベル</span><span className="text-3xl font-black text-orange-600">{level}</span></div>
                                <div className="flex flex-col items-center items-end"><span className="text-sm text-gray-500 font-bold">スコア</span><span className="text-3xl font-black text-gray-900">{score}</span></div>
                            </div>
                        </div>
                    </div>
                    <div className="flex-1 flex flex-col justify-center items-center gap-6">
                        <div className="text-center h-10">
                            {gameState === 'showing' && <span className="text-orange-600 text-3xl font-black animate-pulse">場所を覚えて！</span>}
                            {gameState === 'playing' && <span className="text-green-700 text-3xl font-black">同じ場所を押して</span>}
                            {gameState === 'success' && <span className="text-blue-700 text-3xl font-black">正解！</span>}
                        </div>
                        <div className={`grid gap-3 p-4 bg-gray-200 rounded-3xl shadow-inner w-full max-w-[360px] ${gridSize === 3 ? 'grid-cols-3' : 'grid-cols-4'}`}>
                            {Array.from({ length: gridSize * gridSize }).map((_, i) => {
                                const isTarget = sequence.includes(i);
                                const isSelected = userSequence.includes(i);
                                let cellClass = "bg-white border-b-4 border-gray-300";
                                if (gameState === 'showing' && isTarget) cellClass = "bg-orange-500 border-orange-700 shadow-[0_0_20px_rgba(249,115,22,0.8)] scale-95";
                                else if (isSelected) cellClass = "bg-green-600 border-green-800 scale-95";
                                return <button key={i} onClick={() => onClickTile(i)} disabled={gameState !== 'playing'} className={`aspect-square rounded-xl transition-all duration-200 transform ${cellClass} shadow-md active:scale-90`} />;
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const NumberGame = ({ onEnd, onExit }) => {
            const { numbers, currentTarget, score, timeLeft, isActive, startGame, handleClick } = useNumberGame(onEnd);
            const [feedback, setFeedback] = useState(null);
            useEffect(() => { startGame(); }, []);

            const onClickNum = (num) => {
                const isCorrect = handleClick(num);
                if (isCorrect) {
                     // small feedback or sound
                }
            };

            return (
                <div className="flex flex-col h-full relative">
                    <GameHeader title="数字早押し" score={score} timeLeft={timeLeft} onExit={onExit} color="text-teal-700" />
                    <div className="flex-1 flex flex-col justify-center items-center gap-6">
                        <div className="flex items-center gap-4 bg-teal-50 px-8 py-4 rounded-full border-2 border-teal-200 shadow-sm">
                            <span className="text-teal-900 text-xl font-bold">次は</span>
                            <span className="text-5xl font-black text-teal-700">{currentTarget}</span>
                        </div>
                        <div className="grid grid-cols-4 gap-3 w-full aspect-square p-2">
                            {numbers.map((num) => {
                                const isClicked = num < currentTarget;
                                return (
                                    <button key={num} onClick={() => onClickNum(num)} disabled={!isActive || isClicked} className={`rounded-2xl font-black text-3xl shadow-md transition-all duration-100 flex items-center justify-center ${isClicked ? 'bg-gray-100 text-gray-300 scale-95 shadow-inner' : 'bg-white text-gray-900 border-b-[6px] border-gray-300 active:border-b-0 active:translate-y-1 hover:bg-gray-50'}`}>{num}</button>
                                )
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const RPSGame = ({ onEnd, onExit }) => {
            const { enemyHand, instruction, score, timeLeft, isActive, startGame, handleAnswer } = useRPSGame(onEnd);
            const [feedback, setFeedback] = useState(null);
            useEffect(() => { startGame(); }, []);

            const onAnswer = (hand) => {
                if (!isActive) return;
                const isCorrect = handleAnswer(hand);
                setFeedback(null);
                setTimeout(() => setFeedback(isCorrect ? 'correct' : 'wrong'), 0);
                setTimeout(() => setFeedback(null), 500);
            };

            const handIcons = [<RockHand className="w-24 h-24" />, <ScissorsHand className="w-24 h-24" />, <PaperHand className="w-24 h-24" />];
            const handNames = ["グー", "チョキ", "パー"];
            const instructions = [
                { text: "勝って！", color: "text-red-700", bg: "bg-red-50 border-red-300 ring-4 ring-red-100" },
                { text: "負けて！", color: "text-blue-700", bg: "bg-blue-50 border-blue-300 ring-4 ring-blue-100" },
                { text: "あいこで！", color: "text-green-700", bg: "bg-green-50 border-green-300 ring-4 ring-green-100" }
            ];

            return (
                <div className="flex flex-col h-full relative">
                    <FeedbackOverlay type={feedback} />
                    <GameHeader title="後出しジャンケン" score={score} timeLeft={timeLeft} onExit={onExit} color="text-pink-700" />
                    <div className="flex-1 flex flex-col items-center justify-between py-2">
                        <div className="flex flex-col items-center gap-2">
                            <span className="text-gray-500 font-bold text-lg">相手の手</span>
                            <div className="w-40 h-40 bg-white rounded-full flex items-center justify-center border-[6px] border-gray-200 shadow-md">
                                <div className="text-gray-800">{handIcons[enemyHand]}</div>
                            </div>
                            <span className="text-4xl font-black text-gray-900 mt-1">{handNames[enemyHand]}</span>
                        </div>
                        <div className={`px-12 py-5 rounded-3xl border-4 font-black text-4xl tracking-widest shadow-lg ${instructions[instruction].bg} ${instructions[instruction].color} transition-colors duration-300`}>
                            {instructions[instruction].text}
                        </div>
                        <div className="w-full">
                            <span className="text-gray-500 font-bold text-lg text-center block mb-3">あなたの手</span>
                            <div className="grid grid-cols-3 gap-3">
                                <Button variant="rock" onClick={() => onAnswer(0)} disabled={!isActive} className="h-28 flex-col text-lg pt-2"><RockHand className="w-10 h-10 mb-1" /> グー</Button>
                                <Button variant="scissors" onClick={() => onAnswer(1)} disabled={!isActive} className="h-28 flex-col text-lg pt-2"><ScissorsHand className="w-10 h-10 mb-1" /> チョキ</Button>
                                <Button variant="paper" onClick={() => onAnswer(2)} disabled={!isActive} className="h-28 flex-col text-lg pt-2"><PaperHand className="w-10 h-10 mb-1" /> パー</Button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const ResultScreen = ({ score, onRetry, onHome }) => {
            return (
                <div className="flex flex-col items-center justify-center h-full animate-fade-in text-center p-6 bg-white/80 rounded-3xl">
                    <div className="mb-8 animate-bounce"><Trophy className="w-24 h-24 text-yellow-500" /></div>
                    <h2 className="text-7xl font-black text-gray-900 mb-2">{score}</h2>
                    <p className="text-gray-600 text-xl font-bold tracking-widest mb-12">点数</p>
                    <div className="flex flex-col gap-5 w-full">
                        <Button onClick={onRetry} variant="primary" className="text-2xl h-20"><RotateCcw className="w-8 h-8" /> もう一度やる</Button>
                        <Button onClick={onHome} variant="secondary" className="text-2xl h-20"><Home className="w-8 h-8" /> メニューに戻る</Button>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [screen, setScreen] = useState('menu');
            const [lastGame, setLastGame] = useState(null);
            const [lastScore, setLastScore] = useState(0);
            const [highScores, setHighScores] = useState({ math: 0, color: 0, memory: 0, rps: 0, number: 0 });

            useEffect(() => {
                const saved = localStorage.getItem('brain-gym-senior-scores');
                if (saved) { try { setHighScores(JSON.parse(saved)); } catch (e) {} }
            }, []);

            const saveScore = (gameId, score) => {
                const newHighScores = { ...highScores, [gameId]: Math.max(highScores[gameId] || 0, score) };
                setHighScores(newHighScores);
                localStorage.setItem('brain-gym-senior-scores', JSON.stringify(newHighScores));
                setLastScore(score);
                setLastGame(gameId);
                setScreen('result');
            };

            const handleRetry = () => {
                if (lastGame) setScreen(lastGame);
                else setScreen('menu');
            };

            const renderScreen = () => {
                switch (screen) {
                    case 'menu': return <MenuScreen onSelectGame={(g) => { setScreen(g); setLastGame(g); }} highScores={highScores} />;
                    case 'math': return <MathGame onEnd={(s) => saveScore('math', s)} onExit={() => setScreen('menu')} />;
                    case 'color': return <ColorGame onEnd={(s) => saveScore('color', s)} onExit={() => setScreen('menu')} />;
                    case 'memory': return <MemoryGame onEnd={(s) => saveScore('memory', s)} onExit={() => setScreen('menu')} />;
                    case 'rps': return <RPSGame onEnd={(s) => saveScore('rps', s)} onExit={() => setScreen('menu')} />;
                    case 'number': return <NumberGame onEnd={(s) => saveScore('number', s)} onExit={() => setScreen('menu')} />;
                    case 'result': return <ResultScreen score={lastScore} onRetry={handleRetry} onHome={() => setScreen('menu')} />;
                    default: return <MenuScreen onSelectGame={setScreen} highScores={highScores} />;
                }
            };

            return (
                <div className="w-full h-full relative">
                     <div className="w-full max-w-lg bg-white min-h-[700px] h-[90vh] rounded-[2rem] shadow-2xl overflow-hidden relative flex flex-col p-6 border-4 border-white mx-auto">
                        {renderScreen()}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
